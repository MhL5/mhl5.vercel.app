### Compare with try-catch

with `try` and `catch`

```tsx
try {
  const user = await getUser();
} catch (error) {
  // handle the error
}
```

<br />

with `tryCatch`:

```tsx
const [error, data] = await tryCatch(getUser());

if (error) {
  // handle the error
}

// data is the user object
data.name;
```

the return type is a tuple: either `[error, undefined]` or `[undefined, data]`. This enforces type safety by requiring you to handle potential errors before accessing the data.

### typescript example

You can also add type arguments to the `tryCatch` function to enforce type safety. the first type argument is the type of the data, the second type argument is the type of the error.

```tsx
type User = {
  name: string;
};

type Error = {
  message: string;
  status: number;
};

const [error, data] = await tryCatch<User, Error>(getUser());

if (error) {
  // handle the error, error is of type Error defined above
  console.log(error.message);
}

// data is the user object, it is of type User defined above
data.name;
```

## Installation

<InstallationTabs name="tryCatch" />

## Usage

### tryCatch

```tsx
type User = {
  name: string;
};

type Error = {
  errorMessage: string;
};

const [error, user] = tryCatch<User, Error>(getUser());

if (error) {
  // handle the error
  console.log(error.errorMessage);
}

user.name;
```

### tryCatchSync

```tsx
const [error, data] = tryCatchSync(new Intl.NumberFormat(locale).format(count));
```
