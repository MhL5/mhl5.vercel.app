{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "useLocalStorage",
  "type": "registry:hook",
  "title": "useLocalStorage",
  "description": "A React hook built on top of `useSyncExternalStore` that synchronizes state with `localStorage`, providing reactive updates across browser tabs and windows.",
  "registryDependencies": [
    "https://mhl5.vercel.app/r/checks.json"
  ],
  "files": [
    {
      "path": "src/registry/hooks/useLocalStorage/useLocalStorage.ts",
      "content": "\"use client\";\r\n\r\nimport { useCallback, useMemo, useSyncExternalStore } from \"react\";\r\nimport { isDev } from \"@/registry/utils/checks/checks\";\r\n\r\n/**\r\n * A React hook that synchronizes state with localStorage, providing reactive updates\r\n * across browser tabs and windows.\r\n *\r\n * @remarks\r\n * ## Key Features:\r\n * - **Cross-tab synchronization**: Changes in one tab automatically update all other tabs\r\n * - **Infinite loop prevention**: Uses string snapshots internally to prevent React re-render loops\r\n * - **Automatic cleanup**: Setting `null`, `undefined`, or `\"\"` removes the item from localStorage\r\n * - **Error handling**: Falls back to initialValue if JSON parsing fails\r\n *\r\n * ## Important Limitations:\r\n * - **No SSR support**: This hook must only be called on the client side. The server snapshot\r\n *   always returns `null`, which will cause the initial value to be used during hydration.\r\n * - **JSON serialization**: Only values that can be serialized with `JSON.stringify()` are supported.\r\n *   Functions, `undefined`, and circular references cannot be stored.\r\n *\r\n * ## How it works:\r\n * 1. Uses `useSyncExternalStore` to subscribe to localStorage changes\r\n * 2. Listens to native `storage` events (for changes from other tabs)\r\n * 3. Dispatches custom `local-storage-change` events (for changes in the current tab)\r\n * 4. Returns a string snapshot to prevent infinite loops, then parses it in a `useMemo`\r\n *\r\n * @example\r\n *\r\n * // Basic usage\r\n * const [count, setCount] = useLocalStorage('count', 0);\r\n */\r\nexport function useLocalStorage<T>(key: string, initialValue: T | (() => T)) {\r\n  /**\r\n   * we cant parse the json here because if the parsed value is an object, it will cause an infinite loop\r\n   * we will only return a string snapshot and parse it after (string is a primitive value)\r\n   */\r\n  const getSnapshot = useCallback(() => localStorage.getItem(key), [key]);\r\n\r\n  /**\r\n   * for server side rendering, we return null, there is no ssr support for this hook\r\n   * ensure that this hook is called only on the client side\r\n   */\r\n  const getServerSnapshot = useCallback(() => null, []);\r\n\r\n  /**\r\n   * Subscribe to the storage event\r\n   * storage event gets called for other tabs but not for the current tab (other tabs)\r\n   * we use local-storage-change event for the current tab\r\n   */\r\n  const subscribe = useCallback(\r\n    (onChange: () => void) => {\r\n      const abortController = new AbortController();\r\n\r\n      window.addEventListener(\r\n        \"storage\",\r\n        (e) => {\r\n          if (e.key === key) onChange();\r\n        },\r\n        {\r\n          signal: abortController.signal,\r\n        },\r\n      );\r\n      window.addEventListener(\r\n        \"local-storage-change\",\r\n        (e) => {\r\n          const customEvent = e as CustomEvent;\r\n          if (customEvent.detail.key === key) onChange();\r\n        },\r\n        {\r\n          signal: abortController.signal,\r\n        },\r\n      );\r\n\r\n      return () => abortController.abort();\r\n    },\r\n    [key],\r\n  );\r\n\r\n  /**\r\n   * useSyncExternalStore hook will cause infinite loop if the snapshot is not a primitive value\r\n   *\r\n   * we will return a string snapshot and parse it after (string is a primitive value)\r\n   *\r\n   * this way even if the parsed value is not a primitive value, it will not cause an infinite loop\r\n   */\r\n  const snapshotString = useSyncExternalStore(\r\n    subscribe,\r\n    getSnapshot,\r\n    getServerSnapshot,\r\n  );\r\n\r\n  /**\r\n   * parses the snapshot string to the actual value\r\n   *\r\n   * returns the resolved initial value if the parsing fails\r\n   */\r\n  const parsedSnapshot = useMemo(() => {\r\n    const resolvedInitialValue =\r\n      initialValue instanceof Function ? initialValue() : initialValue;\r\n    try {\r\n      return snapshotString ? JSON.parse(snapshotString) : resolvedInitialValue;\r\n    } catch (error) {\r\n      if (isDev())\r\n        // biome-ignore lint/suspicious/noConsole: only logs on development\r\n        console.error(`Error parsing value for ${key} in localStorage`, error);\r\n      return resolvedInitialValue;\r\n    }\r\n  }, [snapshotString, initialValue, key]);\r\n\r\n  /**\r\n   * sets the value to the local storage\r\n   *\r\n   * dispatches a custom event to the current tab to notify other tabs about the change\r\n   *\r\n   * if the value is null or undefined or empty string, it will remove the item from the local storage\r\n   */\r\n  const setData = useCallback(\r\n    (value: T | ((prev: T) => T)) => {\r\n      const resolvedValue =\r\n        value instanceof Function ? value(parsedSnapshot) : value;\r\n\r\n      const isResolvedValueInvalid =\r\n        resolvedValue === undefined ||\r\n        resolvedValue === null ||\r\n        resolvedValue === \"\";\r\n\r\n      if (isResolvedValueInvalid) localStorage.removeItem(key);\r\n      else localStorage.setItem(key, JSON.stringify(resolvedValue));\r\n      window.dispatchEvent(\r\n        new CustomEvent(\"local-storage-change\", { detail: { key } }),\r\n      );\r\n    },\r\n    [key, parsedSnapshot],\r\n  );\r\n\r\n  return useMemo(\r\n    () => [parsedSnapshot, setData] as const,\r\n    [parsedSnapshot, setData],\r\n  );\r\n}\r\n",
      "type": "registry:hook"
    }
  ]
}