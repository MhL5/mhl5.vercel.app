{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "useIsVisible",
  "type": "registry:hook",
  "title": "useIsVisible",
  "description": "A hook for checking if an element is visible in the viewport using Intersection Observer API.",
  "files": [
    {
      "path": "src/registry/hooks/useIsVisible/useIsVisible.ts",
      "content": "\"use client\";\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\ntype UseIsVisibleOptions = {\n  rootMargin?: IntersectionObserverInit[\"rootMargin\"];\n  root?: IntersectionObserverInit[\"root\"];\n  threshold?: IntersectionObserverInit[\"threshold\"];\n  once?: boolean;\n  initialState?: boolean | (() => boolean);\n};\n\nexport type UseIsVisibleRef = ReturnType<typeof useIsVisible>[\"ref\"];\n\nexport default function useIsVisible({\n  rootMargin = \"0px\",\n  root,\n  threshold,\n  once = false,\n  initialState = false,\n}: UseIsVisibleOptions = {}) {\n  const [isVisible, setIsVisible] = useState(() => {\n    if (initialState instanceof Function) return initialState();\n    return initialState;\n  });\n  const rootRef = useRef<UseIsVisibleOptions[\"root\"]>(root);\n  const thresholdRef = useRef<UseIsVisibleOptions[\"threshold\"]>(threshold);\n\n  // refCallback automatically triggers when the element changes, while useRef doesn't\n  // using useRef can break the logic specially if the component gets rendered with a delay due to fetching ...\n  const [element, setElement] = useState<HTMLElement | null>(null);\n  const refCallback = useCallback((node: HTMLElement | null) => {\n    setElement(node);\n  }, []);\n\n  useEffect(() => {\n    rootRef.current = root;\n  }, [root]);\n\n  useEffect(() => {\n    thresholdRef.current = threshold;\n  }, [threshold]);\n\n  useEffect(() => {\n    if (!element) return;\n\n    // IntersectionObserver is async and callback can even run after the component is unmounted\n    // so we need to check if the component is mounted before setting the state\n    let isMounted = true;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (!isMounted) return;\n\n        setIsVisible(entry.isIntersecting);\n        if (once && entry.isIntersecting) observer.disconnect();\n      },\n      { rootMargin, root: rootRef.current, threshold: thresholdRef.current },\n    );\n\n    observer.observe(element);\n\n    return () => {\n      observer.disconnect();\n      observer.unobserve(element);\n      isMounted = false;\n    };\n  }, [element, rootMargin, once]);\n\n  return { isVisible, ref: refCallback };\n}\n",
      "type": "registry:hook"
    }
  ],
  "meta": {
    "url": "/snippets/hooks/useIsVisible"
  }
}